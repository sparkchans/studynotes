1. 要求: 输入某个二叉树的前序遍历和中序遍历的结果, 请重建该二叉树, 假设输入的前序遍历和中序遍历中都不含重复的数字.

2. 分析: 利用二叉树的前序遍历可以找到二叉树的头节点, 利用二叉树的中序遍历可以找到二叉树的左子树和右子树

3. ```java
   public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
       return doConstruct(pre, 0, pre.length - 1, in, 0, in.length - 1);
   }
   
   public TreeNode doConstruct(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd) {
       // 都为空
       if (pre == null && in == null) {
           return null;
       }
       // 长度为 1
       if ((preEnd - preStart + 1) == 1 && (inEnd - inStart + 1) == 1) {
           return new TreeNode(pre[preStart]);
       }
       // 头节点
       TreeNode rootNode = new TreeNode(pre[preStart]);
       int leftCount = 0;
       for (int i = inStart; i <= inEnd; i++) {
           if (in[i] == pre[preStart]) {
               break;
           }
           leftCount++;
       }
       // 只有右子树
       if (leftCount == 0) {
           rootNode.right = doConstruct(pre, preStart + 1, preEnd, in, inStart + 1, inEnd);
           // 左子树和右子树
       } else if (leftCount < (inEnd - inStart)) {
           rootNode.left = doConstruct(pre, preStart + 1, preStart + leftCount, in, inStart, inStart + leftCount - 1);
           rootNode.right = doConstruct(pre, preStart + leftCount + 1, preEnd, in, inStart + leftCount + 1, inEnd);
           // 左子树
       } else {
           rootNode.left = doConstruct(pre, preStart + 1, preEnd, in, inStart, inEnd - 1);
       }
       return rootNode;
   }
   ```

   