1. 要求: 在一个长度为 n 的数组里所有的数字都在 0~n-1 的范围内. 数组中某些数字是重复的, 但不知道有几个数字重复了, 也不知道重复了几次。请找出数组中任意一个重复的数字. 例如, 如果输入长度为 7 的数组 {2, 3, 1, 0, 2, 5, 3}, 那么对应的输出是重复的数字 2 或者 3.
2. 分析: 这道题特殊的地方在于可以通过一次交换就将某个数字放置到排序的正确位置. 比如测试数据中的 5 在递增排序的位置应该属于位置 5. 传统的排序并不能通过一次交换就能够放置到排序的正确位置. ***一次放置到正确的位置上这个条件值得在所遇到的问题中思考***.

3. 代码实现:

   ```java
   public boolean duplicate(int numbers[],int length,int [] duplication) {
   	if (numbers == null || length == 0) {
   		return false;
   	}
       /**
        * 虽然这里有两重循环, 但是内层的 while 循环 k 次, 
        * 就会减少 for 循环 k 次执行, 所以总的复杂度还是 O(n)
        */
   	for (int i = 0; i < length; i++) {
   		int num = numbers[i];
   		while (num != i) {
   			// 当前下标的数据和下标为 num 的数据相等, 则说明该 num 重复了
   			if (numbers[num] == num) {
   				duplication[0] = num;
   				return true;
   			}
   			// 将 numbers[num] 数据交换到当前下标
   			numbers[i] = numbers[num];
   			// 将 num 放置到正确的下标上
   			numbers[num] = num;
   		}
   	}
   }
   ```

   